// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: account.sql

package pdb

import (
	"context"
	"strings"
)

const assignCategoryToTransferTemplate = `-- name: AssignCategoryToTransferTemplate :exec
INSERT INTO transfer_template_category_assignment (transfer_template_id, category_id)
VALUES (?, ?) ON CONFLICT DO NOTHING
`

type AssignCategoryToTransferTemplateParams struct {
	TransferTemplateID string
	CategoryID         string
}

func (q *Queries) AssignCategoryToTransferTemplate(ctx context.Context, arg AssignCategoryToTransferTemplateParams) error {
	_, err := q.db.ExecContext(ctx, assignCategoryToTransferTemplate, arg.TransferTemplateID, arg.CategoryID)
	return err
}

const createAccount = `-- name: CreateAccount :one
INSERT INTO account (
    id,
    name,
    balance_upper_limit,
    cash_flow_frequency,
    cash_flow_destination_id,
    type_id,
    created_at,
    updated_at
  )
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, name, owner_id, created_at, updated_at, balance_upper_limit, cash_flow_frequency, cash_flow_destination_id, type_id
`

type CreateAccountParams struct {
	ID                    string
	Name                  string
	BalanceUpperLimit     *float64
	CashFlowFrequency     *string
	CashFlowDestinationID *string
	TypeID                *string
	CreatedAt             int64
	UpdatedAt             int64
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, createAccount,
		arg.ID,
		arg.Name,
		arg.BalanceUpperLimit,
		arg.CashFlowFrequency,
		arg.CashFlowDestinationID,
		arg.TypeID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BalanceUpperLimit,
		&i.CashFlowFrequency,
		&i.CashFlowDestinationID,
		&i.TypeID,
	)
	return i, err
}

const deleteAccount = `-- name: DeleteAccount :one
DELETE FROM account
WHERE id = ?
RETURNING id, name, owner_id, created_at, updated_at, balance_upper_limit, cash_flow_frequency, cash_flow_destination_id, type_id
`

func (q *Queries) DeleteAccount(ctx context.Context, id string) (Account, error) {
	row := q.db.QueryRowContext(ctx, deleteAccount, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BalanceUpperLimit,
		&i.CashFlowFrequency,
		&i.CashFlowDestinationID,
		&i.TypeID,
	)
	return i, err
}

const deleteAccountType = `-- name: DeleteAccountType :exec
DELETE FROM account_type
WHERE id = ?
`

func (q *Queries) DeleteAccountType(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteAccountType, id)
	return err
}

const deleteGrowthModel = `-- name: DeleteGrowthModel :exec
DELETE FROM growth_model
WHERE id = ?
`

func (q *Queries) DeleteGrowthModel(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteGrowthModel, id)
	return err
}

const deleteInvestmentRound = `-- name: DeleteInvestmentRound :exec
DELETE FROM investment_round
WHERE id = ?
`

func (q *Queries) DeleteInvestmentRound(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteInvestmentRound, id)
	return err
}

const deleteSnapshot = `-- name: DeleteSnapshot :exec
DELETE FROM account_snapshot
WHERE account_id = ?
  AND date = ?
`

type DeleteSnapshotParams struct {
	AccountID string
	Date      int64
}

func (q *Queries) DeleteSnapshot(ctx context.Context, arg DeleteSnapshotParams) error {
	_, err := q.db.ExecContext(ctx, deleteSnapshot, arg.AccountID, arg.Date)
	return err
}

const deleteSpecialDate = `-- name: DeleteSpecialDate :exec
DELETE FROM special_date
WHERE id = ?
`

func (q *Queries) DeleteSpecialDate(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteSpecialDate, id)
	return err
}

const deleteStartupShareAccount = `-- name: DeleteStartupShareAccount :exec
DELETE FROM startup_share_account
WHERE account_id = ?
`

func (q *Queries) DeleteStartupShareAccount(ctx context.Context, accountID string) error {
	_, err := q.db.ExecContext(ctx, deleteStartupShareAccount, accountID)
	return err
}

const deleteStartupShareOption = `-- name: DeleteStartupShareOption :exec
DELETE FROM startup_share_option
WHERE id = ?
`

func (q *Queries) DeleteStartupShareOption(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteStartupShareOption, id)
	return err
}

const deleteTransferTemplate = `-- name: DeleteTransferTemplate :exec
DELETE FROM transfer_template
WHERE id = ?
`

func (q *Queries) DeleteTransferTemplate(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTransferTemplate, id)
	return err
}

const deleteTransferTemplateCategory = `-- name: DeleteTransferTemplateCategory :exec
DELETE FROM transfer_template_category
WHERE id = ?
`

func (q *Queries) DeleteTransferTemplateCategory(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTransferTemplateCategory, id)
	return err
}

const getAccount = `-- name: GetAccount :one
SELECT id, name, owner_id, created_at, updated_at, balance_upper_limit, cash_flow_frequency, cash_flow_destination_id, type_id
FROM account
WHERE id = ?
`

func (q *Queries) GetAccount(ctx context.Context, id string) (Account, error) {
	row := q.db.QueryRowContext(ctx, getAccount, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BalanceUpperLimit,
		&i.CashFlowFrequency,
		&i.CashFlowDestinationID,
		&i.TypeID,
	)
	return i, err
}

const getAccountType = `-- name: GetAccountType :one
SELECT id, name, color
FROM account_type
WHERE id = ?
`

func (q *Queries) GetAccountType(ctx context.Context, id string) (AccountType, error) {
	row := q.db.QueryRowContext(ctx, getAccountType, id)
	var i AccountType
	err := row.Scan(&i.ID, &i.Name, &i.Color)
	return i, err
}

const getCategoriesForTransferTemplate = `-- name: GetCategoriesForTransferTemplate :many
SELECT c.id, c.name, c.color, c.created_at, c.updated_at
FROM transfer_template_category c
  INNER JOIN transfer_template_category_assignment a ON c.id = a.category_id
WHERE a.transfer_template_id = ?
`

func (q *Queries) GetCategoriesForTransferTemplate(ctx context.Context, transferTemplateID string) ([]TransferTemplateCategory, error) {
	rows, err := q.db.QueryContext(ctx, getCategoriesForTransferTemplate, transferTemplateID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TransferTemplateCategory
	for rows.Next() {
		var i TransferTemplateCategory
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Color,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChildTemplates = `-- name: GetChildTemplates :many
SELECT id, name, from_account_id, to_account_id, amount_type, amount_fixed, amount_percent, priority, recurrence, start_date, end_date, enabled, created_at, updated_at, parent_template_id
FROM transfer_template
WHERE parent_template_id = ?
ORDER BY start_date,
  name,
  id
`

func (q *Queries) GetChildTemplates(ctx context.Context, parentTemplateID *string) ([]TransferTemplate, error) {
	rows, err := q.db.QueryContext(ctx, getChildTemplates, parentTemplateID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TransferTemplate
	for rows.Next() {
		var i TransferTemplate
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.FromAccountID,
			&i.ToAccountID,
			&i.AmountType,
			&i.AmountFixed,
			&i.AmountPercent,
			&i.Priority,
			&i.Recurrence,
			&i.StartDate,
			&i.EndDate,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParentTemplateID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGrowthModel = `-- name: GetGrowthModel :one
SELECT id, account_id, model_type, annual_growth_rate, annual_volatility, start_date, end_date, created_at, updated_at
FROM growth_model
WHERE id = ?
`

func (q *Queries) GetGrowthModel(ctx context.Context, id string) (GrowthModel, error) {
	row := q.db.QueryRowContext(ctx, getGrowthModel, id)
	var i GrowthModel
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.ModelType,
		&i.AnnualGrowthRate,
		&i.AnnualVolatility,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGrowthModelsByAccount = `-- name: GetGrowthModelsByAccount :many
SELECT id, account_id, model_type, annual_growth_rate, annual_volatility, start_date, end_date, created_at, updated_at
FROM growth_model
WHERE account_id = ?
`

func (q *Queries) GetGrowthModelsByAccount(ctx context.Context, accountID string) ([]GrowthModel, error) {
	rows, err := q.db.QueryContext(ctx, getGrowthModelsByAccount, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GrowthModel
	for rows.Next() {
		var i GrowthModel
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.ModelType,
			&i.AnnualGrowthRate,
			&i.AnnualVolatility,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvestmentRound = `-- name: GetInvestmentRound :one
SELECT id, account_id, date, valuation, created_at, updated_at
FROM investment_round
WHERE id = ?
`

func (q *Queries) GetInvestmentRound(ctx context.Context, id string) (InvestmentRound, error) {
	row := q.db.QueryRowContext(ctx, getInvestmentRound, id)
	var i InvestmentRound
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Date,
		&i.Valuation,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLatestInvestmentRound = `-- name: GetLatestInvestmentRound :one
SELECT id, account_id, date, valuation, created_at, updated_at
FROM investment_round
WHERE account_id = ?
  AND date <= ?
ORDER BY date DESC
LIMIT 1
`

type GetLatestInvestmentRoundParams struct {
	AccountID string
	Date      int64
}

func (q *Queries) GetLatestInvestmentRound(ctx context.Context, arg GetLatestInvestmentRoundParams) (InvestmentRound, error) {
	row := q.db.QueryRowContext(ctx, getLatestInvestmentRound, arg.AccountID, arg.Date)
	var i InvestmentRound
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Date,
		&i.Valuation,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSnapshot = `-- name: GetSnapshot :one
SELECT account_id, date, balance
FROM account_snapshot
WHERE account_id = ?
  AND date = ?
`

type GetSnapshotParams struct {
	AccountID string
	Date      int64
}

func (q *Queries) GetSnapshot(ctx context.Context, arg GetSnapshotParams) (AccountSnapshot, error) {
	row := q.db.QueryRowContext(ctx, getSnapshot, arg.AccountID, arg.Date)
	var i AccountSnapshot
	err := row.Scan(&i.AccountID, &i.Date, &i.Balance)
	return i, err
}

const getSnapshotsByAccount = `-- name: GetSnapshotsByAccount :many
SELECT account_id, date, balance
FROM account_snapshot
WHERE account_id = ?
`

func (q *Queries) GetSnapshotsByAccount(ctx context.Context, accountID string) ([]AccountSnapshot, error) {
	rows, err := q.db.QueryContext(ctx, getSnapshotsByAccount, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AccountSnapshot
	for rows.Next() {
		var i AccountSnapshot
		if err := rows.Scan(&i.AccountID, &i.Date, &i.Balance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSnapshotsByAccounts = `-- name: GetSnapshotsByAccounts :many
SELECT account_id, date, balance
FROM account_snapshot
WHERE account_id IN (/*SLICE:ids*/?)
ORDER BY date,
  account_id
`

func (q *Queries) GetSnapshotsByAccounts(ctx context.Context, ids []string) ([]AccountSnapshot, error) {
	query := getSnapshotsByAccounts
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AccountSnapshot
	for rows.Next() {
		var i AccountSnapshot
		if err := rows.Scan(&i.AccountID, &i.Date, &i.Balance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpecialDate = `-- name: GetSpecialDate :one
SELECT id, name, date, color
FROM special_date
WHERE id = ?
`

func (q *Queries) GetSpecialDate(ctx context.Context, id string) (SpecialDate, error) {
	row := q.db.QueryRowContext(ctx, getSpecialDate, id)
	var i SpecialDate
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Date,
		&i.Color,
	)
	return i, err
}

const getSpecialDates = `-- name: GetSpecialDates :many
SELECT id, name, date, color
FROM special_date
ORDER BY date,
  name,
  id
`

func (q *Queries) GetSpecialDates(ctx context.Context) ([]SpecialDate, error) {
	rows, err := q.db.QueryContext(ctx, getSpecialDates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SpecialDate
	for rows.Next() {
		var i SpecialDate
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Date,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStartupShareAccount = `-- name: GetStartupShareAccount :one
SELECT account_id, shares_owned, total_shares, purchase_price_per_share, tax_rate, valuation_discount_factor
FROM startup_share_account
WHERE account_id = ?
`

func (q *Queries) GetStartupShareAccount(ctx context.Context, accountID string) (StartupShareAccount, error) {
	row := q.db.QueryRowContext(ctx, getStartupShareAccount, accountID)
	var i StartupShareAccount
	err := row.Scan(
		&i.AccountID,
		&i.SharesOwned,
		&i.TotalShares,
		&i.PurchasePricePerShare,
		&i.TaxRate,
		&i.ValuationDiscountFactor,
	)
	return i, err
}

const getStartupShareOption = `-- name: GetStartupShareOption :one
SELECT id, account_id, source_account_id, shares, strike_price_per_share, grant_date, end_date, created_at, updated_at
FROM startup_share_option
WHERE id = ?
`

func (q *Queries) GetStartupShareOption(ctx context.Context, id string) (StartupShareOption, error) {
	row := q.db.QueryRowContext(ctx, getStartupShareOption, id)
	var i StartupShareOption
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.SourceAccountID,
		&i.Shares,
		&i.StrikePricePerShare,
		&i.GrantDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransferTemplate = `-- name: GetTransferTemplate :one
SELECT id, name, from_account_id, to_account_id, amount_type, amount_fixed, amount_percent, priority, recurrence, start_date, end_date, enabled, created_at, updated_at, parent_template_id
FROM transfer_template
WHERE id = ?
`

func (q *Queries) GetTransferTemplate(ctx context.Context, id string) (TransferTemplate, error) {
	row := q.db.QueryRowContext(ctx, getTransferTemplate, id)
	var i TransferTemplate
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.FromAccountID,
		&i.ToAccountID,
		&i.AmountType,
		&i.AmountFixed,
		&i.AmountPercent,
		&i.Priority,
		&i.Recurrence,
		&i.StartDate,
		&i.EndDate,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ParentTemplateID,
	)
	return i, err
}

const getTransferTemplateCategory = `-- name: GetTransferTemplateCategory :one
SELECT id, name, color, created_at, updated_at
FROM transfer_template_category
WHERE id = ?
`

func (q *Queries) GetTransferTemplateCategory(ctx context.Context, id string) (TransferTemplateCategory, error) {
	row := q.db.QueryRowContext(ctx, getTransferTemplateCategory, id)
	var i TransferTemplateCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Color,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransferTemplates = `-- name: GetTransferTemplates :many
SELECT id, name, from_account_id, to_account_id, amount_type, amount_fixed, amount_percent, priority, recurrence, start_date, end_date, enabled, created_at, updated_at, parent_template_id
FROM transfer_template
ORDER BY recurrence,
  priority,
  name,
  start_date,
  end_date,
  created_at
`

func (q *Queries) GetTransferTemplates(ctx context.Context) ([]TransferTemplate, error) {
	rows, err := q.db.QueryContext(ctx, getTransferTemplates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TransferTemplate
	for rows.Next() {
		var i TransferTemplate
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.FromAccountID,
			&i.ToAccountID,
			&i.AmountType,
			&i.AmountFixed,
			&i.AmountPercent,
			&i.Priority,
			&i.Recurrence,
			&i.StartDate,
			&i.EndDate,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParentTemplateID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccountTypes = `-- name: ListAccountTypes :many
SELECT id, name, color
FROM account_type
ORDER BY name,
  id
`

func (q *Queries) ListAccountTypes(ctx context.Context) ([]AccountType, error) {
	rows, err := q.db.QueryContext(ctx, listAccountTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AccountType
	for rows.Next() {
		var i AccountType
		if err := rows.Scan(&i.ID, &i.Name, &i.Color); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccounts = `-- name: ListAccounts :many
SELECT id, name, owner_id, created_at, updated_at, balance_upper_limit, cash_flow_frequency, cash_flow_destination_id, type_id
FROM account
ORDER BY name,
  id
`

func (q *Queries) ListAccounts(ctx context.Context) ([]Account, error) {
	rows, err := q.db.QueryContext(ctx, listAccounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OwnerID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BalanceUpperLimit,
			&i.CashFlowFrequency,
			&i.CashFlowDestinationID,
			&i.TypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveGrowthModels = `-- name: ListActiveGrowthModels :many
SELECT id, account_id, model_type, annual_growth_rate, annual_volatility, start_date, end_date, created_at, updated_at
FROM growth_model
WHERE end_date IS NULL
  OR end_date > ?1
  AND start_date <= ?1
`

func (q *Queries) ListActiveGrowthModels(ctx context.Context, param1 *int64) ([]GrowthModel, error) {
	rows, err := q.db.QueryContext(ctx, listActiveGrowthModels, param1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GrowthModel
	for rows.Next() {
		var i GrowthModel
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.ModelType,
			&i.AnnualGrowthRate,
			&i.AnnualVolatility,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvestmentRounds = `-- name: ListInvestmentRounds :many
SELECT id, account_id, date, valuation, created_at, updated_at
FROM investment_round
WHERE account_id = ?
ORDER BY date DESC,
  id
`

func (q *Queries) ListInvestmentRounds(ctx context.Context, accountID string) ([]InvestmentRound, error) {
	rows, err := q.db.QueryContext(ctx, listInvestmentRounds, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InvestmentRound
	for rows.Next() {
		var i InvestmentRound
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Date,
			&i.Valuation,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLatestSnapshotPerAccount = `-- name: ListLatestSnapshotPerAccount :many
SELECT s.account_id, s.date, s.balance
FROM account_snapshot s
  INNER JOIN (
    SELECT account_id,
      MAX(date) AS max_date
    FROM account_snapshot
    GROUP BY account_id
  ) latest ON s.account_id = latest.account_id
  AND s.date = latest.max_date
`

func (q *Queries) ListLatestSnapshotPerAccount(ctx context.Context) ([]AccountSnapshot, error) {
	rows, err := q.db.QueryContext(ctx, listLatestSnapshotPerAccount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AccountSnapshot
	for rows.Next() {
		var i AccountSnapshot
		if err := rows.Scan(&i.AccountID, &i.Date, &i.Balance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStartupShareOptions = `-- name: ListStartupShareOptions :many
SELECT id, account_id, source_account_id, shares, strike_price_per_share, grant_date, end_date, created_at, updated_at
FROM startup_share_option
WHERE account_id = ?
ORDER BY grant_date,
  id
`

func (q *Queries) ListStartupShareOptions(ctx context.Context, accountID string) ([]StartupShareOption, error) {
	rows, err := q.db.QueryContext(ctx, listStartupShareOptions, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StartupShareOption
	for rows.Next() {
		var i StartupShareOption
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.SourceAccountID,
			&i.Shares,
			&i.StrikePricePerShare,
			&i.GrantDate,
			&i.EndDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransferTemplateCategories = `-- name: ListTransferTemplateCategories :many
SELECT id, name, color, created_at, updated_at
FROM transfer_template_category
ORDER BY name,
  id
`

func (q *Queries) ListTransferTemplateCategories(ctx context.Context) ([]TransferTemplateCategory, error) {
	rows, err := q.db.QueryContext(ctx, listTransferTemplateCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TransferTemplateCategory
	for rows.Next() {
		var i TransferTemplateCategory
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Color,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeCategoryFromTransferTemplate = `-- name: RemoveCategoryFromTransferTemplate :exec
DELETE FROM transfer_template_category_assignment
WHERE transfer_template_id = ?
  AND category_id = ?
`

type RemoveCategoryFromTransferTemplateParams struct {
	TransferTemplateID string
	CategoryID         string
}

func (q *Queries) RemoveCategoryFromTransferTemplate(ctx context.Context, arg RemoveCategoryFromTransferTemplateParams) error {
	_, err := q.db.ExecContext(ctx, removeCategoryFromTransferTemplate, arg.TransferTemplateID, arg.CategoryID)
	return err
}

const updateAccount = `-- name: UpdateAccount :one
UPDATE account
SET name = ?,
  updated_at = ?,
  balance_upper_limit = ?,
  cash_flow_frequency = ?,
  cash_flow_destination_id = ?,
  type_id = ?
WHERE id = ?
RETURNING id, name, owner_id, created_at, updated_at, balance_upper_limit, cash_flow_frequency, cash_flow_destination_id, type_id
`

type UpdateAccountParams struct {
	Name                  string
	UpdatedAt             int64
	BalanceUpperLimit     *float64
	CashFlowFrequency     *string
	CashFlowDestinationID *string
	TypeID                *string
	ID                    string
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, updateAccount,
		arg.Name,
		arg.UpdatedAt,
		arg.BalanceUpperLimit,
		arg.CashFlowFrequency,
		arg.CashFlowDestinationID,
		arg.TypeID,
		arg.ID,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BalanceUpperLimit,
		&i.CashFlowFrequency,
		&i.CashFlowDestinationID,
		&i.TypeID,
	)
	return i, err
}

const updateSnapshotDate = `-- name: UpdateSnapshotDate :many
UPDATE account_snapshot
SET date = ?
WHERE date = ?
RETURNING account_id, date, balance
`

type UpdateSnapshotDateParams struct {
	Date   int64
	Date_2 int64
}

func (q *Queries) UpdateSnapshotDate(ctx context.Context, arg UpdateSnapshotDateParams) ([]AccountSnapshot, error) {
	rows, err := q.db.QueryContext(ctx, updateSnapshotDate, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AccountSnapshot
	for rows.Next() {
		var i AccountSnapshot
		if err := rows.Scan(&i.AccountID, &i.Date, &i.Balance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertAccountType = `-- name: UpsertAccountType :one
INSERT INTO account_type (id, name, color)
VALUES (?, ?, ?) ON CONFLICT (id) DO
UPDATE
SET name = EXCLUDED.name,
  color = EXCLUDED.color
RETURNING id, name, color
`

type UpsertAccountTypeParams struct {
	ID    string
	Name  string
	Color *string
}

func (q *Queries) UpsertAccountType(ctx context.Context, arg UpsertAccountTypeParams) (AccountType, error) {
	row := q.db.QueryRowContext(ctx, upsertAccountType, arg.ID, arg.Name, arg.Color)
	var i AccountType
	err := row.Scan(&i.ID, &i.Name, &i.Color)
	return i, err
}

const upsertGrowthModel = `-- name: UpsertGrowthModel :one
INSERT INTO growth_model (
    id,
    account_id,
    model_type,
    annual_growth_rate,
    annual_volatility,
    start_date,
    end_date,
    created_at,
    updated_at
  )
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?) ON CONFLICT (id) DO
UPDATE
SET model_type = EXCLUDED.model_type,
  annual_growth_rate = EXCLUDED.annual_growth_rate,
  annual_volatility = EXCLUDED.annual_volatility,
  start_date = EXCLUDED.start_date,
  end_date = EXCLUDED.end_date,
  updated_at = EXCLUDED.updated_at
RETURNING id, account_id, model_type, annual_growth_rate, annual_volatility, start_date, end_date, created_at, updated_at
`

type UpsertGrowthModelParams struct {
	ID               string
	AccountID        string
	ModelType        string
	AnnualGrowthRate string
	AnnualVolatility string
	StartDate        int64
	EndDate          *int64
	CreatedAt        int64
	UpdatedAt        int64
}

func (q *Queries) UpsertGrowthModel(ctx context.Context, arg UpsertGrowthModelParams) (GrowthModel, error) {
	row := q.db.QueryRowContext(ctx, upsertGrowthModel,
		arg.ID,
		arg.AccountID,
		arg.ModelType,
		arg.AnnualGrowthRate,
		arg.AnnualVolatility,
		arg.StartDate,
		arg.EndDate,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i GrowthModel
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.ModelType,
		&i.AnnualGrowthRate,
		&i.AnnualVolatility,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertInvestmentRound = `-- name: UpsertInvestmentRound :one
INSERT INTO investment_round (
    id,
    account_id,
    date,
    valuation,
    created_at,
    updated_at
  )
VALUES (?, ?, ?, ?, ?, ?) ON CONFLICT (account_id, date) DO
UPDATE
SET valuation = EXCLUDED.valuation,
  updated_at = EXCLUDED.updated_at
RETURNING id, account_id, date, valuation, created_at, updated_at
`

type UpsertInvestmentRoundParams struct {
	ID        string
	AccountID string
	Date      int64
	Valuation float64
	CreatedAt int64
	UpdatedAt int64
}

func (q *Queries) UpsertInvestmentRound(ctx context.Context, arg UpsertInvestmentRoundParams) (InvestmentRound, error) {
	row := q.db.QueryRowContext(ctx, upsertInvestmentRound,
		arg.ID,
		arg.AccountID,
		arg.Date,
		arg.Valuation,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i InvestmentRound
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Date,
		&i.Valuation,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertSnapshot = `-- name: UpsertSnapshot :one
INSERT INTO account_snapshot (account_id, date, balance)
VALUES (?, ?, ?) ON CONFLICT (account_id, date) DO
UPDATE
SET balance = EXCLUDED.balance
RETURNING account_id, date, balance
`

type UpsertSnapshotParams struct {
	AccountID string
	Date      int64
	Balance   string
}

func (q *Queries) UpsertSnapshot(ctx context.Context, arg UpsertSnapshotParams) (AccountSnapshot, error) {
	row := q.db.QueryRowContext(ctx, upsertSnapshot, arg.AccountID, arg.Date, arg.Balance)
	var i AccountSnapshot
	err := row.Scan(&i.AccountID, &i.Date, &i.Balance)
	return i, err
}

const upsertSpecialDate = `-- name: UpsertSpecialDate :one
INSERT INTO special_date (id, name, date, color)
VALUES (?, ?, ?, ?) ON CONFLICT (id) DO
UPDATE
SET name = EXCLUDED.name,
  date = EXCLUDED.date,
  color = EXCLUDED.color
RETURNING id, name, date, color
`

type UpsertSpecialDateParams struct {
	ID    string
	Name  string
	Date  string
	Color *string
}

func (q *Queries) UpsertSpecialDate(ctx context.Context, arg UpsertSpecialDateParams) (SpecialDate, error) {
	row := q.db.QueryRowContext(ctx, upsertSpecialDate,
		arg.ID,
		arg.Name,
		arg.Date,
		arg.Color,
	)
	var i SpecialDate
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Date,
		&i.Color,
	)
	return i, err
}

const upsertStartupShareAccount = `-- name: UpsertStartupShareAccount :one
INSERT INTO startup_share_account (
    account_id,
    shares_owned,
    total_shares,
    purchase_price_per_share,
    tax_rate,
    valuation_discount_factor
  )
VALUES (?, ?, ?, ?, ?, ?) ON CONFLICT (account_id) DO
UPDATE
SET shares_owned = EXCLUDED.shares_owned,
  total_shares = EXCLUDED.total_shares,
  purchase_price_per_share = EXCLUDED.purchase_price_per_share,
  tax_rate = EXCLUDED.tax_rate,
  valuation_discount_factor = EXCLUDED.valuation_discount_factor
RETURNING account_id, shares_owned, total_shares, purchase_price_per_share, tax_rate, valuation_discount_factor
`

type UpsertStartupShareAccountParams struct {
	AccountID               string
	SharesOwned             float64
	TotalShares             float64
	PurchasePricePerShare   float64
	TaxRate                 float64
	ValuationDiscountFactor float64
}

func (q *Queries) UpsertStartupShareAccount(ctx context.Context, arg UpsertStartupShareAccountParams) (StartupShareAccount, error) {
	row := q.db.QueryRowContext(ctx, upsertStartupShareAccount,
		arg.AccountID,
		arg.SharesOwned,
		arg.TotalShares,
		arg.PurchasePricePerShare,
		arg.TaxRate,
		arg.ValuationDiscountFactor,
	)
	var i StartupShareAccount
	err := row.Scan(
		&i.AccountID,
		&i.SharesOwned,
		&i.TotalShares,
		&i.PurchasePricePerShare,
		&i.TaxRate,
		&i.ValuationDiscountFactor,
	)
	return i, err
}

const upsertStartupShareOption = `-- name: UpsertStartupShareOption :one
INSERT INTO startup_share_option (
    id,
    account_id,
    source_account_id,
    shares,
    strike_price_per_share,
    grant_date,
    end_date,
    created_at,
    updated_at
  )
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?) ON CONFLICT (id) DO
UPDATE
SET account_id = EXCLUDED.account_id,
  source_account_id = EXCLUDED.source_account_id,
  shares = EXCLUDED.shares,
  strike_price_per_share = EXCLUDED.strike_price_per_share,
  grant_date = EXCLUDED.grant_date,
  end_date = EXCLUDED.end_date,
  updated_at = EXCLUDED.updated_at
RETURNING id, account_id, source_account_id, shares, strike_price_per_share, grant_date, end_date, created_at, updated_at
`

type UpsertStartupShareOptionParams struct {
	ID                  string
	AccountID           string
	SourceAccountID     string
	Shares              float64
	StrikePricePerShare float64
	GrantDate           int64
	EndDate             int64
	CreatedAt           int64
	UpdatedAt           int64
}

func (q *Queries) UpsertStartupShareOption(ctx context.Context, arg UpsertStartupShareOptionParams) (StartupShareOption, error) {
	row := q.db.QueryRowContext(ctx, upsertStartupShareOption,
		arg.ID,
		arg.AccountID,
		arg.SourceAccountID,
		arg.Shares,
		arg.StrikePricePerShare,
		arg.GrantDate,
		arg.EndDate,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i StartupShareOption
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.SourceAccountID,
		&i.Shares,
		&i.StrikePricePerShare,
		&i.GrantDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertTransferTemplate = `-- name: UpsertTransferTemplate :one
INSERT INTO transfer_template (
    id,
    name,
    from_account_id,
    to_account_id,
    amount_type,
    amount_fixed,
    amount_percent,
    priority,
    recurrence,
    start_date,
    end_date,
    enabled,
    parent_template_id,
    created_at,
    updated_at
  )
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) ON CONFLICT (id) DO
UPDATE
SET name = EXCLUDED.name,
  from_account_id = EXCLUDED.from_account_id,
  to_account_id = EXCLUDED.to_account_id,
  amount_type = EXCLUDED.amount_type,
  amount_fixed = EXCLUDED.amount_fixed,
  amount_percent = EXCLUDED.amount_percent,
  priority = EXCLUDED.priority,
  recurrence = EXCLUDED.recurrence,
  start_date = EXCLUDED.start_date,
  end_date = EXCLUDED.end_date,
  enabled = EXCLUDED.enabled,
  parent_template_id = EXCLUDED.parent_template_id,
  updated_at = EXCLUDED.updated_at
RETURNING id, name, from_account_id, to_account_id, amount_type, amount_fixed, amount_percent, priority, recurrence, start_date, end_date, enabled, created_at, updated_at, parent_template_id
`

type UpsertTransferTemplateParams struct {
	ID               string
	Name             string
	FromAccountID    *string
	ToAccountID      *string
	AmountType       string
	AmountFixed      string
	AmountPercent    float64
	Priority         int64
	Recurrence       string
	StartDate        int64
	EndDate          *int64
	Enabled          bool
	ParentTemplateID *string
	CreatedAt        int64
	UpdatedAt        int64
}

func (q *Queries) UpsertTransferTemplate(ctx context.Context, arg UpsertTransferTemplateParams) (TransferTemplate, error) {
	row := q.db.QueryRowContext(ctx, upsertTransferTemplate,
		arg.ID,
		arg.Name,
		arg.FromAccountID,
		arg.ToAccountID,
		arg.AmountType,
		arg.AmountFixed,
		arg.AmountPercent,
		arg.Priority,
		arg.Recurrence,
		arg.StartDate,
		arg.EndDate,
		arg.Enabled,
		arg.ParentTemplateID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i TransferTemplate
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.FromAccountID,
		&i.ToAccountID,
		&i.AmountType,
		&i.AmountFixed,
		&i.AmountPercent,
		&i.Priority,
		&i.Recurrence,
		&i.StartDate,
		&i.EndDate,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ParentTemplateID,
	)
	return i, err
}

const upsertTransferTemplateCategory = `-- name: UpsertTransferTemplateCategory :one
INSERT INTO transfer_template_category (id, name, color, created_at, updated_at)
VALUES (?, ?, ?, ?, ?) ON CONFLICT (id) DO
UPDATE
SET name = EXCLUDED.name,
  color = EXCLUDED.color,
  updated_at = EXCLUDED.updated_at
RETURNING id, name, color, created_at, updated_at
`

type UpsertTransferTemplateCategoryParams struct {
	ID        string
	Name      string
	Color     *string
	CreatedAt int64
	UpdatedAt int64
}

func (q *Queries) UpsertTransferTemplateCategory(ctx context.Context, arg UpsertTransferTemplateCategoryParams) (TransferTemplateCategory, error) {
	row := q.db.QueryRowContext(ctx, upsertTransferTemplateCategory,
		arg.ID,
		arg.Name,
		arg.Color,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i TransferTemplateCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Color,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
